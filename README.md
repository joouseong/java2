# 주우성 202230236

## 3월 27일(4주차)

### 자바의 특징
가비지 컬렉션
* 자바 언어는 메모리 할당 기능은 있어도 메모리 반환 기능 없음
* 사용하지 않는 메모리는 JVM에 의해 자동 반환 - 가비지 컬렉션

실시간 응용프로그램에 부적합
* 실행 도중 예측할 수 없는 시점에 가비지 컬렉션 실행 때문
* 응용프로그램의 일시적 중단 발생

자바 프로그램은 안전
* 타임 체크 엄격
* 물리적 주소 ???를 사용하는 포인터 개념 없음

프로그램 작성 쉬움
* 포인터 개념이 없음. 동작 메모리 반환 하지 않음. 다양한 라이브러리 지원

실행 속도 개선을 위한 JIT 컴파일러 사용
* 자바는 바이트 코드를 인터프리터 방식으로 실행
* 기계어가 실행되는 것보다 느림
* JIT컴파일 기법으로 실행 속도 개선
* JIT 컴파일 - 실행 중에 바이트 코드를 컴파일하여 기계어를 실행하는 기법

### 소스 코드, 바이트 코드, 기계어
1. 소스코드(source code)
* 우리가 작성하는 Java 코드(.Java 파일)
* 사람이 읽을 수 있는 고수준 언어(하이레벨랭귀지)

2. 바이트 코드(.class 파일)
* Java 컴파일러(Javac)가 소스코드를 변환한 중간 코드
* CPU가 직접 실행할 수 없음 -> JVM이 실행해야 함
* 기계어와 다르게 플랫폼 독립적
* 바이트 코드는 JVM이 해석(인터프리터)하거나, JIT 컴파일러가 기계어로 변환 실행 됨

3. 기계어(Machine Code)
* CPU가 직접 실행할 수 있는 0과 1의 이진 코드
* 운영체제(OS)와 CPU 아키텍쳐(intel, ARM 등)에 따라 다름
* 16진수 형태의 기계어

바이트코드와 기계어의 차이점
* 바이트 코드는 JVM이 실행하는 중간 코드 -> 운영체제와 CPU에 관계없이 사용 가능
* 기계어는 CPU가 직접 실행하는 코드 -> 특정 하드웨어에 종속됨

### 자바 기본 프로그래밍

식별자(identifier) - 명명 규칙(Naming Convention)
* 식별자: 클래스, 변수, 상수, 메소드 등에 붙이는 이름
* '@', '#', '!'와 같은 특수문자, 공백 또는 탭은 식별자로 사용불가 '_', '$'는 사용 가능
* 유니코드 문자 사용 가능, 한글 사용 가능 but 한글은 사용 X
* 자바 언어의 키워드는 식별자로 사용 불가
* 식별자의 첫 번째 문자로 숫자는 사용 불가
* '_' 또는 '$'를 식별자 첫 번째 문자로 사용할 수 있으나 일반적으로 잘 사용하지 않는다
* 불린  리터럴(true, faluse)와 널 리터럴(null)은 식별자로 사용 불가
* 길이 제한 없음
* 대소문자 구별: barChart 와 barchart 는 다른 식별자

Java의 데이터 타입
* 기본 자료형(Primitive Type) 8개
* 기본 타입의 크기는 CPU나 운영체제에 따라 변하지 않음
* 레퍼런스형 1개이며 용도는 다음 3가지: 포인터와 유사한 개념이지만 메모리 주소는 아님
  1. 클래스에 대한 레퍼런스
  2. 인터페이스에 대한 레퍼런스
  3. 배열에 대한 레퍼런스
* 문자열은 기본 타입이 아님. String 클래스로 문자열 표현
* 문자열 리터럴: "JDK", "한글"
  1. 리터럴 이란 소스코드 중 특정한 자료형의 값을 의미
* 문자열이나 문자열과 다른 자료형의 리터럴을 + 연산을 할 경우 결과는 문자열로 변환

참조 자료형(REference Type)
* 포인터는 임의의 메모리 주소를 저장 하는 반면, 참조 자료형은 주소를 지정할 수 없음
* 직접 주소를 갖고 있지는 않지만, JVM이 해당 주소로 안내해 주게 됨
* 객체를 잠조하는 변수 유형으로, 힙(Heap) 영역에 저장된 객체의 메모리 주소를 가리킴
* 기본 자료형은 스택(Stack) 영역에 저장됨
* New 키워드로 객체(인스턴스)를 생성하는 것이 바로 참조 자료형을 선언하는 것
* 이렇게 선언된 참조 자료형은 JVM이 대신 객체의 주소를 저장
* 배열, 인터페이스 혹은 열거형도 객체이기 때문에 참조 자료형임
* 객체를 참조하지 않을 때 null 값을 가질 수 있음
* 같은 객체를 여러 변수가 참조할 수 있고, ==연산자로 객체의 주소 비교 할 수도 있음
* 일반적으로 '레퍼런스'라고 부르면 되지만, 레퍼런스형, 레퍼런스 자료형, 참조형,  참조자료형, 레퍼런스 변수, 참조 변수 등 다양하게 사용

Java는 왜 참조 자료형을 사용할까?
* 메모리 설정 자율성
1. 포인터는 개발자가 임의로 메모리 값을 설정하고 해당 메모리에 직접 접근이 가능하기에 참조 자료형에 비해 상대적으로 메모리 설정 자율성이 높음
* 메모리 관리 편의성
1. 자바는 참조 자료형을 사용하는 대신 Garbage Collector를 사용하여 개발자 대신 참조되지 않는 메모리는 자동으로 해제하여 메모리를 효율적으로 관리함
* 안전성
1. JVM과 GC를 통해 스스로 메모리 관리를 하고 개발자가 직접적으로 메모리에 접근하는 것을 막아 이러한 오류를 방지함
* 성능


메모리의 구조
* 힙(Heap - FIFO) 영역은 프로그래머가 직접 공간을 할당, 해제하는 메모리 공간으로 Java의 경우 JVM이 담당
* 스택(Stack - LIFO) 영역은 프로그램이 자동으로 사용하는 임시 메모리 영역
* 힙이 스택을 침범하는 경우를 힙 오버 플로우라 하고, 스택이 힙을 침범하는 경우를 스택 오버 플로우라고 함

변수의 선언
* 변수: 프로그램 실행 중에 값을 임시로 저장하기 위한 메모리의 공간으로 프로그램 수행 중 변경될 수 있음
* 변수 선언: 데이터 타입에서 정한 크기의 메모리를 할당




---
## 3월 20일(3주차)
#### README.md 파일 편집
*이름 학번 h1 제일 위에 기재

*날짜(주차)

*배운내용&코드

*최근 날짜가 제일 위로 올라오게

---
## 수업 내용

### Java Project 생성
1. Command Pallet 키: ctrl+shift+p
2. JAVA: CREATE Java Project 선택
3. No build tools 선택
4. 프로젝트 이름 설정

워킹 디렉토리와 프로젝트 디렉토리를 구분

### 프로그래밍 언어
[기계어]

0, 1의 이진수로 구성된 언어

컴퓨터의 CPU는 기계어만 이해하고 처리가 가능

[어셈블리어]

기계어 명령을 ADD, SU, MOVE 등과 같은 표현하기 쉬운 상징적인 단어인 니모닉 기호(mnemonic symbol)로 일대일 대응시킨 언어

[고급언어]

사람이 사용하는 언어로 이해하기 쉽고, 쉽게 표현할 수 있도록 고안된 언어

Pascal, Basic, C/C++, Java, c# 

절차 지향 언어와 객체 지향 언어로 나눌 수 있음

### 프로그램 언어의 패러다임 변화
[절차 지향 언어]

프로그램을 절차, 순서에 따라서 실행하는 방식

데이터(입력)와 함수를 분리하여 작성

코드의 유연성이 부족, 재사용 어려움

전역 변수를 많이 사용하기 때문에 코드의 가독성과 유지보수가 어려움

C, Pascal, Fortran 등이 있음

[객체 지향 언어]

현실의 객체를 모델링하여 프로그램을 작성하는 방식

객체는 데이터와 데이터를 처리하는 메소드(함수)를 모두 포함

상속, 캡슐화, 다형성 등의 개념을 활용하여 유연하고 재사용 가능한 코드를 작성할 수 있음

Java, C++, Python

[함수 지향 언어]

함수형 언어는 함수를 일급 객체로 취급, 상태 변경을 피하고 불변성을 지향하는 프로그래밍 패러다임

함수형 언어에서는 함수의 조합으로 복잡한 작업을 수행, 상태 변경 대신 데이터를 변환하는 방식으로 프로그램을 작성

### 프로그래밍 언어의 진화
1950s COBOL, Fortran, Lisp

1960s ALGOL 60, BASIC

1970s SQL, C, Pascal, Smalltalk

1980s Objective-C, C++, Pert

1990s JavaScript, Java, Ruby, Python, PHP

2000s Scala, C#, Go lang

2010s Swift, TypeScript, Dart, Rust

### 프로그래밍과 컴파일
소스: 프로그래밍 언어로 작성된 텍스트 파일

컴파일: 소스 파일을 컴퓨터가 이해할 수 있는 기계어로 만드는 과정

자바: .java -> .class(반 정도 컴파일)
C: .c -> .obj -> .exe
C++: .cpp -> .obj -> .exe

### 자바의 태동
1991년 그린 프로젝트(Green Project)로 시작
* 선마이크로시스템즈의 제임스 고슬링에 의해 시작
* 가전 제품에 들어갈 소프트웨어를 위해 개발
* 1995년에 자바 발표
* 초기 이름은 오크(OAK)였으며 인터넷과 웹의 발전과 함께 성장

[목적]

플랫폼 호환성 문제 해결
* 기존 언어로 다시 작성된 프로그램은 플랫폼 간에 호환성 없음
* 소스를 다시 컴파일 하거나 프로그램을 재작성해야 하는 단점

플랫폼 독립적인 언어 개발
* 모든 플랫폼에서 호환성을 갖는 프로그래밍 언어 필요
* 네트워크, 특히 웹에 최적화된 프로그래밍 언어의 필요성 대두

메모리 사용량이 적고 다양한 플랫폼을 가지는 가전 제품에 적용
* 가전제품: 작은 량의 메모리를 가지는 제어 장치
* 내장형 시스템 요구 충족

### 기존 언어의 플랫폼 종속성
플랫폼 = 하드웨어 플랫폼 + 운영체제 플랫폼

프로그램의 플랫폼 호환성이 없는 이유
* 기계어가 CPU마다 다름
* 운영체제마다 API 다름
* 운영체제마다 실행파일 형식 다름

### 자바의 플랫폼 독립성,WORA
WORA(Write Once Run Anywhere)
* 한번 작성된 코드는 수정없이 실행가능
* 운영체제나 CPU 등 플랫폼에 상관없이 자바 가상 기계(JVM)만 있으면 어떤 컴퓨터에서든 동일하게 실행

### 자바 JVM과 자바 실행 환경
바이트 코드(.class)
* 자바 JVM에서 실행가능한 바이너리 코드
* 바이트 코드는 컴퓨터 CPU에 의해 직접 실행되지 않음
* 자바JVM이 작동 중인 플랫폼에서 실행
* 자바 JVM이 인터프리터 방식으로 바이트 코드 해석

### JVM(Java Virtual Machine)
* 각기 다른 플랫폼에 맞는 JVM을 제공 JVM 자체는 플랫폼에 종속적
* JVM 각기 다른 플랫폼에서도 동일한 자바 실행 환경을 제공
* JVM은 자바 개발사인 오라클 외 IBM, MS 등 다양한 회사에서 제작 공급
* 자바의 실행은 JVM에서 클래스 파일(.class)을 바이트 코드 실행 하는 것

### 자바 응용프로그램 실행 환경
실행환경은 JVM + java API(클래스 라이브러리)로 구성

응용프로그램의 실행
* main()메소드를 가진 클래스의 main()에서 실행
* JVM은 필요할 때 클래스 파일 로딩하기 때문에 적은 메모리로도 실행 가능

### JDK와 JRE
JDK의 bin 디렉토리에 포홤된 주요 개발 도구
* javac: 자바 소스를 바이트 코드로 변환하는 컴파일러 
* java: 자바 응용프로그램 실행기. 자바 JVM를 작동시켜 자바프로그램 실행 
* javadoc: 자바 소스로브터 HTML 형식의 API 도큐먼트 생성
* jar: 자바 클래스들(패키치포함)을 압축한 자바 아카이브 파일(.jar) 생성 관리
* jmod: 자바의 모듈 파일(.jmod)을 만들거나 모듈 파일의 내용 출력
* jlink: 응용프로그램에 맞춘 맞춤형(custom) JRE 제공
* jdb: 자바 응용프로그램의 실행 중 오류를 찾는 데 사용하는 디버거
* javap: 클래스 파일의 바이트 코드를 소스와 함께 보여주는 디어셈블러

JDK > JRE > JVM, Java Class Library
    > Java Dev Tools > javac, java ...

### Java 표준안
* Java SE(Standard Edition)
* Java EE(Enterprise Edition)
* Java ME(Micro Edition)

### Java의 네이밍 방식
초기 버전 표기법은 1.x 방식으로 표기됨

1.2 버전에서 J2SE(Java2 Standard Edition)으로 변경

1.6 버전부터 Java SE 6 형태로 변경

내부 버전 표기는 1.x.x 형태로 유지되고 있음

### Java 9부터 시작된 모듈 프로그래밍
모듈화(modularity):Java 9에서 정의된 새로운 기능,2017년 9월 21일 출시

모듈: 자바 패키지들과 이미지,XML 파일 등의 자원들을 묶은 단위

모듈 프로그래밍: 프로그램을 레고 만들듯이 필요한 모듈을 연결하는 방식으로 작성

### 자바 플랫폼의 모듈화
* 실행 시간에 사용되는 자바API의 모든 클래스들을 모듈로 분할
* 세밀한 모듈화, 자바 응용프로그램이 실행되는데 필요없는 모듈 배재
* 작은 크기의 실행 환경 구성
* 하드웨어가 열악한 소형 IoT 장치 지원

최근 프로그래밍 방식이 모듈화, 컴포넌트화로 생산성을 높이는 방식으로 바뀌고 있음

### 자바에서 제공하는 전체 모듈 리스트(Java SE)
Java 9부터 SE의 모든 클래스들을 모듈로 재구성

JDK의 설치 디렉토리 밑의 jmods 디렉토리에서 확인 가능

### 자바 API
자바 AP(Application Programming Interface)란
* JDK에 포함된 클래스 라이브러리
* 개발자는 API를 이용하여 쉽고 빠르게 자바 프로그램 개발

자바 패키지(package)
* 자바 API(클래스 라이브러리)는 JDK에 패키지 형태로 제공
* 서로 관련된 클래스들을 분류하여 계층 구조로 묶어 놓은 것

### 자바 소스 편집
src에 Hello.java 파일을 생성

``` java
public class Hello {
    public static void main(String[] args) {
        System.out.println("Hello");
    }
}
```
작성

터미널에서 경로를 src로 변환(cd src)

리스트 확인(ls)

클래스 생성(javac Hello.java)(src에 Hello.class 생성됨)

실행(java Hello)

결과: Hello

### 자바 응용프로그램의 종류
데스크톱 응용프로그램
* 가장 일반적인 자바 응용프로그램
* JRE이 설치된 어떤 컴퓨터에서도 실행되며 다른 응용프로그램의 도움 없이 단독으로 실행됨

서블릿 응용프로그램
* 웹 서버에서 실행되는 자바 프로그램
* 사용자 인터페이스를 필요로 하지 않으며 웹 서버에 의해 실행이 제어

모바일 응용프로그램
* 현재 가장 많이 응용되는 것이 안드로이드 플랫폼
* 구글의 주도로 여러 모바일 회사가 모여 개발한 무료 모바일 플랫폼이 안드로이드

### 자바의 특성
플랫폼 독립성
* 하드웨어, 운영체제에 종속되지 않는 바이트 코드로 플랫폼 독립성

객체지향
* 캡슐화, 상속, 다형성 지원

클래스로 캡슐화
* 자바의 모든 변수나 함수는 클래스 내에 선언
* 클래스 안에서 클래스, 즉 내부 클래스 작성 가능

소스(.java)와 클래스(.class) 파일
* 하나의 소스 파일에 여러 클래스를 작성가능:public 클래스는 하나만 가능
* 내부 클래스 각각의 클래스파일이 생성됨

실행 코드 배포
* 한 개의 class 파일 또는 다수의 Class 파일로 구성
* 여러 폴더에 걸쳐 다수의 클래스 파일로 구성된 경우: jar 압축 파일로 배포
* 자바 응용프로그램의 실행은 main() 메소드에서 시작
* 하나의 클래스 파일에 두 개 이상의 main()메소드가 있을 수 없음
* 각 클래스 파일이 main()메소드를 포함하는 것은 상관 없음

패키지
* 서로 관련 있는 여러 클래스를 패키지로 묶어 관리
* 패키지는 폴더 개념

예: java.lang.System은 java\lang 디렉토리의 Sysstem.class파일

멀티스레드
* 여러 스레드의 동시 수행 환경 지원
* 자바는 운영체제의 도움 없이 자체적으로 멀티스레드 지원
* C/C++ 프로그램은 멀티스레드를 위해 운영체제 API를 호출

---

## 3월 13일(2주차)
#### github 연동

# h1 tag
## h2
### h3
#### h4
##### h5 
###### h6



---

* 가가가
- 나나나


1. 나나나
2. 다다다
5. 라라라

```java
public class Main {
  public static void main(String[] args) {
    System.out.println("Hello World");
  }
}

```
<<<<<<< HEAD

=======
>>>>>>> 137a4e284297681cf370973170c26c2b8cfe7476
